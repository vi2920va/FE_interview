# Lexical Scope - Dynamic Scope

각각의 변수들은 스코프를 가지고 있는데, 이 스코프는 변수를 찾기 위해 접근할 수 있는 모든 영역이라고 생각하면 된다.

자바스크립트에서는 엔진이 변수를 찾기 위해 사용하는 규칙들의 집합들을 스코프라고 정의할 수 있다.

스코프 모델은 다양하게 있는 데 그 중 유명한 것은 두 가지가 있다. 바로 렉시컬 스코프와 동적 스코프이다. 렉시컬 스코프는 정적인 스코프라고 말하기도 하며, 이는 함수가 선언될 때 그 곳에서 스코프가 결정된다. 반면 동적 스코프는 런타임에서 함수가 어디서 어떻게 실행되느냐에 따라서 스코프가 변하게 된다.

## Dynamic scope

동적 스코프에서 순서는 다음과 같다.

1. 로컬 함수 내부를 살핀다.
2. 이 로컬 함수를 호출한 함수를 찾아가 확인한다.
3. 2번을 반복하면서 타고타고 올라간다.

동적 스코프는 런타임시에 함수가 어디에서 실행되었는지에 따라서 동적으로 스코프가 결정된다. 아래 예시에서 foo만 실행했을 때는 해당 함수의 상위 스코프가 전역이 되기 때문에 a의 값이 2가 되지만, bar 안에서 호출이 되었을 경우에는 상위 스코프가 bar 함수가 된다. 따라서 그 내부에 있는 a 변수가 참조되어 a는 3이 된다. (자바스크립트는 Dynamic scope이 아닌 Lexical scope를 따르기 때문에 아래 코드처럼 동작하지 않는다. 만약 자바스크립트가 동적 스코프로 동작했다면 아래와 같은 결과가 나왔을 것이라는 가정임.)

```jsx
function foo() {
	console.log(a); 
}

function bar() {
	var a = 3;
	foo();
}

var a = 2;

foo(); //2
bar(); //3
```

## Lexical scope

렉시컬 스코프는 lexing time(구문 분석 시간)에 정의되는 스코프 모델이다. 그래서 정적 스코프라고 부르기도 한다.

렉시컬 스코프 언어에서 스코프는 해당 함수가 **실제로 선언된 위치에 고정**된다. 위의 코드와 같은 코드를 렉시컬 스코프에서 실행시키면 결과가 달리 나오게 된다. foo함수는 구문 분석을 할 때, 이미 스코프가 `foo함수의 스코프영역 → 전역 스코프영역` 으로 결정되었다. 그래서 a를 찾기 위해 bar 함수를 뒤질 필요 없이 바로 a는 2라고 알게된다.

```jsx
function foo() {
	console.log(a); 
}

function bar() {
	var a = 3;
	foo();
}

var a = 2;

foo(); //2
bar(); //2
```

## 요약

- 동적 스코프는 실행 시간에 스코프가 정해진다.
- 렉시컬 스코프는 실행 전 구문 분석 시에 스코프가 정해진다.

## 참고

- [미디엄 블로그 - Lexical scope vs Dynamic scope](https://medium.com/@osmanakar_65575/javascript-lexical-and-dynamic-scoping-72c17e4476dd)